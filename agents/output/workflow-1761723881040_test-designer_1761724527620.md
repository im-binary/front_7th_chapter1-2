## 테스트 전략

### 접근 방식

- 방법론: TDD (Test-Driven Development)
- 원칙: F.I.R.S.T 원칙 준수
- 중점: 사용자 시나리오 중심, 비즈니스 가치 검증

### 중점 영역

1.  핵심: 반복 일정 생성 로직 (특수 케이스 포함)
2.  사용자 인터랙션: 반복 일정 UI 요소 활성화 및 입력 처리
3.  에러 처리: 반복 일정 생성 중 API 오류, 유효성 검사
4.  데이터 무결성: 반복 규칙에 따른 정확한 일정 데이터 생성 및 저장

### 목표 커버리지

- 라인 커버리지: 90% (의미있는 코드에 대해)
- 브랜치 커버리지: 85% (모든 조건문 분기)
- 함수 커버리지: 95% (public 함수)
- 중요: 단순 커버리지 숫자보다 의미있는 테스트 작성

### 테스트 우선순위

1.  High: 반복 일정의 핵심 생성 로직 (특수 케이스 포함), 다중 저장 및 단일 알림
2.  Medium: 반복 일정 UI 활성화 및 유효성 검사, 일반 반복 유형 생성
3.  Low: 폼 초기화, 사소한 UI 디테일

## 테스트 케이스 목록

### TC001: 반복 일정 UI - 반복 일정 스위치 활성화 시 관련 UI가 표시된다

- 기능 ID: F001
- 테스트 유형: integration
- 우선순위: medium
- 설명: 사용자가 반복 일정 스위치를 켜면, 반복 유형, 간격, 종료일 입력 필드가 화면에 나타나는지 검증합니다.
- Given (초기 조건):
  - 일정 추가/수정 폼이 열려 있는 상태.
  - 반복 일정 스위치가 꺼져 있는 상태.
- When (실행 동작):
  - 사용자가 "반복 일정" 스위치를 켠다.
- Then (예상 결과):
  - "반복 유형", "반복 간격", "반복 종료일" 레이블을 가진 입력 필드들이 화면에 표시된다.
  - "매일", "매주", "매월", "매년" 선택지가 있는 반복 유형 드롭다운이 표시된다.
- 검증 포인트:
  1. UI 표시: 반복 관련 필드들이 `getByText` 또는 `getByRole`로 접근 가능한지 확인.
  2. 기본값: 반복 유형의 기본값이 "매일" 또는 설정된 기본값으로 선택되어 있는지 확인.
- 엣지 케이스:
  - 스위치를 다시 끄면 관련 UI가 사라지는지.
- Mock/Stub 요구사항:
  - API 호출 없음. 컴포넌트 렌더링 및 사용자 인터랙션.

### TC002: 반복 일정 UI - 반복 간격의 기본값은 1이다

- 기능 ID: F001
- 테스트 유형: integration
- 우선순위: medium
- 설명: 반복 일정 UI 활성화 시, 반복 간격 입력 필드의 기본값이 1로 설정되어 있는지 검증합니다.
- Given (초기 조건):
  - 일정 추가/수정 폼이 열려 있는 상태.
  - 반복 일정 스위치가 켜져 있는 상태.
- When (실행 동작):
  - 사용자가 반복 일정 스위치를 켠다.
- Then (예상 결과):
  - "반복 간격" 입력 필드의 값이 1로 표시된다.
- 검증 포인트:
  1. 기본값 확인: 반복 간격 TextField의 `value`가 1인지 확인.
- 엣지 케이스:
  - 없음.
- Mock/Stub 요구사항:
  - API 호출 없음.

### TC003: 반복 일정 UI - 반복 종료일은 2025-12-31을 초과하여 선택할 수 없다

- 기능 ID: F001
- 테스트 유형: integration
- 우선순위: high
- 설명: 반복 종료일 입력 필드가 2025-12-31 이후 날짜를 선택할 수 없도록 제한하는지 검증합니다.
- Given (초기 조건):
  - 일정 추가/수정 폼이 열려 있는 상태.
  - 반복 일정 스위치가 켜져 있는 상태.
- When (실행 동작):
  - 사용자가 "반복 종료일" 입력 필드를 클릭하여 날짜 선택기를 연다.
  - (테스트 환경에서) 2026년 날짜를 선택하려고 시도한다.
- Then (예상 결과):
  - 2025-12-31 이후의 날짜는 비활성화되거나 선택할 수 없도록 표시된다.
  - 입력 필드에 직접 '2026-01-01'을 입력해도 유효성 검사 오류가 발생하거나 값이 설정되지 않는다.
- 검증 포인트:
  1. 최대 날짜 제한: TextField의 `inputProps`에 `max: '2025-12-31'` 속성이 올바르게 적용되었는지 확인 (MUI 내부 동작 검증).
  2. 값 입력 제한: 2026-01-01과 같은 날짜를 입력 시, 값이 설정되지 않거나 유효성 경고가 표시되는지 확인.
- 엣지 케이스:
  - 2025-12-31을 정확히 선택할 수 있는지.
- Mock/Stub 요구사항:
  - API 호출 없음.

### TC004: useEventForm 훅 - 반복 관련 상태 설정 함수들을 반환한다

- 기능 ID: F002
- 테스트 유형: unit
- 우선순위: high
- 설명: useEventForm 훅이 `setRepeatType`, `setRepeatInterval`, `setRepeatEndDate` 함수를 올바르게 반환하여 App.tsx에서 사용할 수 있는지 검증합니다.
- Given (초기 조건):
  - `useEventForm` 훅을 컴포넌트 내에서 호출한다.
- When (실행 동작):
  - 훅의 반환 객체를 구조 분해 할당한다.
- Then (예상 결과):
  - 반환 객체에 `setRepeatType`, `setRepeatInterval`, `setRepeatEndDate` 함수들이 포함되어 있다.
  - 각 함수를 호출하여 상태를 변경하면, 해당 상태 변수 (`repeatType`, `repeatInterval`, `repeatEndDate`)의 값이 올바르게 업데이트된다.
- 검증 포인트:
  1. 함수 존재 여부: 반환 객체에 특정 함수들이 존재하는지 확인.
  2. 상태 업데이트: `act`를 사용하여 상태 변경 후, 변경된 상태 값이 올바른지 확인.
- 엣지 케이스:
  - 없음.
- Mock/Stub 요구사항:
  - 없음. `renderHook`을 사용하여 훅을 테스트.

### TC005: generateRecurringEvents - 매일 반복 일정을 올바르게 생성한다

- 기능 ID: F003
- 테스트 유형: unit
- 우선순위: high
- 설명: `generateRecurringEvents` 함수가 'daily' 유형과 지정된 간격에 따라 정확한 날짜의 이벤트를 생성하는지 검증합니다.
- Given (초기 조건):
  - 초기 이벤트 데이터: `initialEvent = { date: '2024-01-01', ... }`
  - 반복 정보: `repeatInfo = { type: 'daily', interval: 2, endDate: '2024-01-07' }`
- When (실행 동작):
  - `generateRecurringEvents(initialEvent, repeatInfo)` 함수를 호출한다.
- Then (예상 결과):
  - 다음 날짜의 이벤트 객체 배열이 반환된다: '2024-01-01', '2024-01-03', '2024-01-05', '2024-01-07'.
  - 각 이벤트 객체는 `initialEvent`의 다른 속성을 유지하고 `repeat` 정보도 포함한다.
- 검증 포인트:
  1. 생성된 이벤트 수: 예상되는 이벤트 배열의 길이와 일치하는지 확인.
  2. 날짜의 정확성: 각 이벤트 객체의 `date` 속성이 예상 날짜와 일치하는지 확인.
  3. 속성 유지: `title`, `startTime` 등 `initialEvent`의 다른 속성들이 유지되는지 확인.
- 엣지 케이스:
  - `interval`이 1인 경우.
  - `endDate`가 시작일과 같은 경우 (하나만 생성).
- Mock/Stub 요구사항:
  - `src/utils/dateUtils.ts`의 `formatDate` 함수를 필요시 모의(mock)하여 일관된 날짜 포맷을 보장할 수 있다.

### TC006: generateRecurringEvents - 매월 반복 (31일 특수 케이스)를 올바르게 처리한다

- 기능 ID: F003
- 테스트 유형: unit
- 우선순위: high
- 설명: 시작일이 31일인 'monthly' 반복 유형에서, 31일이 없는 달에는 일정이 생성되지 않는지 검증합니다.
- Given (초기 조건):
  - 초기 이벤트 데이터: `initialEvent = { date: '2024-01-31', ... }`
  - 반복 정보: `repeatInfo = { type: 'monthly', interval: 1, endDate: '2024-05-31' }`
- When (실행 동작):
  - `generateRecurringEvents(initialEvent, repeatInfo)` 함수를 호출한다.
- Then (예상 결과):
  - 다음 날짜의 이벤트 객체 배열이 반환된다: '2024-01-31', '2024-03-31', '2024-05-31'.
  - 2월 (28/29일)과 4월 (30일)에는 일정이 생성되지 않는다.
- 검증 포인트:
  1. 생성된 이벤트 수: 31일이 있는 달에만 생성되었는지 확인.
  2. 날짜의 정확성: 생성된 이벤트의 `date` 속성이 예상 날짜와 일치하는지 확인.
  3. 건너뛴 달 확인: 31일이 없는 달의 일정이 포함되지 않았는지 확인.
- 엣지 케이스:
  - 30일로 끝나는 달에 30일 시작일로 매월 반복 시.
- Mock/Stub 요구사항:
  - `src/utils/dateUtils.ts`의 `getDaysInMonth`, `formatDate` 함수를 필요시 모의(mock)하여 날짜 계산을 제어할 수 있다.

### TC007: generateRecurringEvents - 매년 반복 (윤년 2월 29일 특수 케이스)를 올바르게 처리한다

- 기능 ID: F003
- 테스트 유형: unit
- 우선순위: high
- 설명: 시작일이 윤년 2월 29일인 'yearly' 반복 유형에서, 비윤년에는 일정이 생성되지 않는지 검증합니다.
- Given (초기 조건):
  - 초기 이벤트 데이터: `initialEvent = { date: '2024-02-29', ... }` (2024년은 윤년)
  - 반복 정보: `repeatInfo = { type: 'yearly', interval: 1, endDate: '2028-02-29' }`
- When (실행 동작):
  - `generateRecurringEvents(initialEvent, repeatInfo)` 함수를 호출한다.
- Then (예상 결과):
  - 다음 날짜의 이벤트 객체 배열이 반환된다: '2024-02-29', '2028-02-29'.
  - 2025년, 2026년, 2027년의 2월 29일 (비윤년)에는 일정이 생성되지 않는다.
- 검증 포인트:
  1. 생성된 이벤트 수: 윤년에만 생성되었는지 확인.
  2. 날짜의 정확성: 생성된 이벤트의 `date` 속성이 예상 날짜와 일치하는지 확인.
  3. 건너뛴 해 확인: 비윤년의 일정이 포함되지 않았는지 확인.
- 엣지 케이스:
  - 2월 28일 시작일로 매년 반복 시 (모든 해에 생성).
- Mock/Stub 요구사항:
  - `src/utils/dateUtils.ts`의 `getDaysInMonth`, `formatDate` 함수를 필요시 모의(mock)하여 날짜 계산을 제어할 수 있다.

### TC008: generateRecurringEvents - 반복 종료일이 2025-12-31을 초과하는 경우 제한한다

- 기능 ID: F003
- 테스트 유형: unit
- 우선순위: high
- 설명: `generateRecurringEvents` 함수가 `repeatInfo.endDate`가 2025-12-31을 초과하더라도, 최대 2025-12-31까지만 일정을 생성하는지 검증합니다.
- Given (초기 조건):
  - 초기 이벤트 데이터: `initialEvent = { date: '2025-12-29', ... }`
  - 반복 정보: `repeatInfo = { type: 'daily', interval: 1, endDate: '2026-01-05' }` (2025-12-31 초과)
- When (실행 동작):
  - `generateRecurringEvents(initialEvent, repeatInfo)` 함수를 호출한다.
- Then (예상 결과):
  - '2025-12-29', '2025-12-30', '2025-12-31' 날짜의 이벤트 객체만 반환된다.
  - 2026년 1월의 이벤트는 생성되지 않는다.
- 검증 포인트:
  1. 최종 날짜 제한: 생성된 이벤트 중 가장 늦은 날짜가 '2025-12-31'인지 확인.
  2. 생성된 이벤트 수: 2025-12-31까지의 이벤트만 포함되었는지 확인.
- 엣지 케이스:
  - `endDate`가 2025-12-31과 정확히 일치하는 경우.
- Mock/Stub 요구사항:
  - `src/utils/dateUtils.ts`의 `formatDate` 함수를 필요시 모의(mock)하여 일관된 날짜 포맷을 보장할 수 있다.

### TC009: 반복 일정 생성 - 겹침 검사를 건너뛰고 여러 이벤트를 저장한다

- 기능 ID: F004
- 테스트 유형: integration
- 우선순위: high
- 설명: 반복 일정 생성 시, 기존 단일 일정 생성과 달리 겹침 검사를 건너뛰고 `saveMultipleEvents`를 통해 모든 반복 일정을 저장하는지 검증합니다.
- Given (초기 조건):
  - 일정 추가/수정 폼이 열려 있고, 반복 일정 스위치가 켜져 있는 상태.
  - 겹치는 기존 일정이 존재한다. (예: 2024-01-01에 이미 다른 일정 존재)
  - `useEventOperations`의 `findOverlappingEvents` 및 `saveEvent` 함수는 모의(mock)된다.
  - `useEventOperations`의 `saveMultipleEvents` 함수는 모의(mock)되고 성공적으로 이벤트를 저장하도록 설정된다.
  - `recurrenceUtils.ts`의 `generateRecurringEvents` 함수는 모의(mock)되고 예상되는 반복 이벤트 목록을 반환하도록 설정된다.
- When (실행 동작):
  - 사용자가 반복 일정 정보를 입력한다 (예: 매일 반복, 2024-01-01 ~ 2024-01-03).
  - "저장" 버튼을 클릭한다.
- Then (예상 결과):
  - `findOverlappingEvents` 함수가 호출되지 않는다.
  - `generateRecurringEvents` 함수가 호출되어 반복 이벤트 목록을 생성한다.
  - `saveMultipleEvents` 함수가 생성된 반복 이벤트 목록을 인자로 받아 호출된다.
  - `saveEvent` 함수가 호출되지 않는다.
  - 폼이 초기화된다.
- 검증 포인트:
  1. 겹침 검사 건너뛰기: `findOverlappingEvents`가 호출되지 않았는지 확인.
  2. 다중 저장 호출: `saveMultipleEvents`가 올바른 인자로 호출되었는지 확인.
  3. 단일 저장 미호출: `saveEvent`가 호출되지 않았는지 확인.
  4. 폼 초기화: 입력 필드들이 초기 상태로 돌아갔는지 확인.
- 엣지 케이스:
  - 없음.
- Mock/Stub 요구사항:
  - `useEventOperations` 훅 전체를 모의(mock)하여 `saveEvent`, `saveMultipleEvents`, `findOverlappingEvents`의 호출 여부를 감시한다.
  - `generateRecurringEvents` 함수를 모의(mock)하여 예상되는 반복 이벤트 배열을 반환하도록 설정한다.

### TC010: 반복 일정 생성 - 모든 반복 일정 저장 후 스낵바 알림이 한 번만 표시된다

- 기능 ID: F004
- 테스트 유형: integration
- 우선순위: high
- 설명: 여러 반복 일정이 성공적으로 저장된 후, 사용자에게 스낵바 알림이 한 번만 표시되는지 검증합니다.
- Given (초기 조건):
  - 일정 추가/수정 폼이 열려 있고, 반복 일정 스위치가 켜져 있는 상태.
  - `useEventOperations`의 `saveMultipleEvents` 함수는 모의(mock)되고 성공적으로 이벤트를 저장하며, 내부적으로 `enqueueSnackbar`를 한 번만 호출하도록 설정된다.
  - `recurrenceUtils.ts`의 `generateRecurringEvents` 함수는 모의(mock)되고 여러 개의 반복 이벤트 목록을 반환하도록 설정된다.
- When (실행 동작):
  - 사용자가 반복 일정 정보를 입력하고 "저장" 버튼을 클릭한다.
- Then (예상 결과):
  - `enqueueSnackbar` 함수가 "반복 일정이 모두 추가되었습니다." 메시지로 한 번만 호출된다.
  - 화면에 해당 스낵바 메시지가 한 번만 표시된다.
- 검증 포인트:
  1. 스낵바 호출 횟수: `enqueueSnackbar`가 정확히 한 번 호출되었는지 확인.
  2. 스낵바 메시지: 표시된 스낵바 메시지가 올바른지 확인.
- 엣지 케이스:
  - 없음.
- Mock/Stub 요구사항:
  - `useEventOperations` 훅을 모의(mock)하여 `saveMultipleEvents`의 동작을 제어한다.
  - `notistack`의 `enqueueSnackbar` 함수를 모의(mock)하여 호출 횟수와 인자를 감시한다.

### TC011: 반복 일정 생성 - API 오류 발생 시 에러 알림이 표시된다

- 기능 ID: F004
- 테스트 유형: integration
- 우선순위: high
- 설명: 반복 일정 생성 중 API 호출에서 오류가 발생했을 때, 사용자에게 적절한 에러 스낵바 알림이 표시되는지 검증합니다.
- Given (초기 조건):
  - 일정 추가/수정 폼이 열려 있고, 반복 일정 스위치가 켜져 있는 상태.
  - `useEventOperations`의 `saveMultipleEvents` 함수는 모의(mock)되고, 내부 API 호출에서 오류를 발생시키도록 설정된다.
  - `recurrenceUtils.ts`의 `generateRecurringEvents` 함수는 모의(mock)되고 반복 이벤트 목록을 반환하도록 설정된다.
- When (실행 동작):
  - 사용자가 반복 일정 정보를 입력하고 "저장" 버튼을 클릭한다.
- Then (예상 결과):
  - `enqueueSnackbar` 함수가 "반복 일정 저장 실패" 메시지로 호출된다.
  - 화면에 에러 스낵바 메시지가 표시된다.
  - 폼이 초기화되지 않고 입력된 상태를 유지한다.
- 검증 포인트:
  1. 에러 스낵바: `enqueueSnackbar`가 에러 메시지와 함께 호출되었는지 확인.
  2. 폼 상태 유지: 폼이 초기화되지 않고 입력된 데이터가 그대로 남아있는지 확인.
- 엣지 케이스:
  - 없음.
- Mock/Stub 요구사항:
  - `useEventOperations` 훅을 모의(mock)하여 `saveMultipleEvents`가 에러를 던지도록 설정한다.
  - `notistack`의 `enqueueSnackbar` 함수를 모의(mock)하여 호출 여부와 인자를 감시한다.
  - `fetch` API를 모의(mock)하여 `response.ok`가 `false`를 반환하도록 설정한다.

### TC012: 단일 일정 생성 - 반복 일정이 아닐 경우 기존 겹침 검사 로직이 유지된다

- 기능 ID: F004
- 테스트 유형: integration
- 우선순위: medium
- 설명: "반복 일정" 스위치가 꺼져 있는 상태에서 일정 생성 시, 기존의 겹침 검사 로직과 `saveEvent` 호출이 올바르게 동작하는지 검증합니다.
- Given (초기 조건):
  - 일정 추가/수정 폼이 열려 있고, 반복 일정 스위치가 꺼져 있는 상태.
  - 겹치는 기존 일정이 존재한다.
  - `useEventOperations`의 `findOverlappingEvents` 및 `saveEvent` 함수는 모의(mock)된다.
- When (실행 동작):
  - 사용자가 단일 일정 정보를 입력한다.
  - "저장" 버튼을 클릭한다.
- Then (예상 결과):
  - `findOverlappingEvents` 함수가 호출된다.
  - 겹치는 일정이 존재하므로 겹침 확인 다이얼로그가 표시된다.
  - `saveEvent` 함수가 즉시 호출되지 않는다 (다이얼로그 확인 후 호출).
  - `saveMultipleEvents` 함수는 호출되지 않는다.
- 검증 포인트:
  1. 겹침 검사 호출: `findOverlappingEvents`가 호출되었는지 확인.
  2. 다이얼로그 표시: 겹침 확인 다이얼로그가 화면에 표시되는지 확인.
  3. 다중 저장 미호출: `saveMultipleEvents`가 호출되지 않았는지 확인.
- 엣지 케이스:
  - 겹치는 일정이 없는 경우, 다이얼로그 없이 `saveEvent`가 호출되는지.
- Mock/Stub 요구사항:
  - `useEventOperations` 훅 전체를 모의(mock)하여 `saveEvent`, `saveMultipleEvents`, `findOverlappingEvents`의 호출 여부를 감시한다.
  - `findOverlappingEvents`가 겹치는 이벤트를 반환하도록 설정한다.

## 테스트 구조 설계

### 파일 구조

```
src/__tests__/
  ├── unit/                    # 단위 테스트
  │   ├── useEventForm.spec.ts
  │   └── recurrenceUtils.spec.ts
  ├── integration/             # 통합 테스트
  │   └── App.spec.tsx
  │   └── useEventOperations.spec.ts
  └── e2e/                     # E2E 테스트 (현재 요구사항에서는 필요성 낮음)
      └── (없음)
```

### 테스트 파일 명명 규칙

- `[테스트대상].[타입].spec.ts`
- 예: `App.integration.spec.tsx`, `recurrenceUtils.unit.spec.ts`

## 테스트 피라미드 구성

### 분포

- 단위 테스트: 5개 (50%)
  - `useEventForm` 훅의 반환 값 및 상태 관리
  - `generateRecurringEvents` 함수 (반복 로직, 특수 케이스)
- 통합 테스트: 7개 (50%)
  - `App.tsx` 컴포넌트와 `useEventForm`, `useEventOperations` 훅의 상호작용
  - `App.tsx`의 반복 일정 UI 활성화 및 입력 처리
  - `addOrUpdateEvent` 로직의 분기 처리 (반복/단일)
  - `saveMultipleEvents`의 알림 처리
- E2E 테스트: 0개 (0%)
  - 현재 기능 범위에서는 E2E 테스트의 추가적인 가치가 크지 않다고 판단.

### 근거

- 단위 테스트 중심: `generateRecurringEvents`와 같은 핵심 비즈니스 로직은 순수 함수로 분리되어 있으므로, 단위 테스트로 빠르고 정확하게 검증합니다. `useEventForm` 훅의 반환 값 검증도 단위 테스트에 적합합니다.
- 통합 테스트 보완: `App.tsx`에서 UI와 훅들이 어떻게 상호작용하며 반복 일정을 생성하고 저장하는지, 그리고 겹침 검사를 건너뛰는 요구사항을 검증하기 위해 통합 테스트를 활용합니다. `saveMultipleEvents`의 단일 알림 처리도 통합 테스트로 검증합니다.
- E2E 최소화: 현재 기능은 특정 사용자 흐름보다는 개별 기능의 정확성에 중점을 두므로, E2E 테스트의 필요성은 낮습니다. 추후 더 복잡한 사용자 시나리오가 추가될 경우 고려할 수 있습니다.

## 테스트 품질 체크리스트

작성된 테스트 케이스가 다음을 만족하는지 확인:

- [x] 사용자 관점에서 작성되었는가?
- [x] 비즈니스 가치를 검증하는가?
- [x] 테스트 이름만으로 무엇을 검증하는지 이해 가능한가?
- [x] 실패 시 문제 위치를 명확히 알 수 있는가?
- [x] 다른 테스트와 독립적으로 실행 가능한가?
- [x] Given-When-Then이 명확히 구분되는가?
- [x] 엣지 케이스와 에러 케이스를 포함하는가?
- [x] Mock을 적절히 사용하여 외부 의존성을 제어하는가?
- [x] 구현 세부사항이 아닌 동작을 테스트하는가?
- [x] 단언문(assertion)이 명확하고 구체적인가?

## 참고: 테스트 작성 예시

### 좋은 예시

```typescript
describe('일정 삭제 확인 다이얼로그', () => {
  it('TC001: 삭제 버튼 클릭 시 확인 다이얼로그가 표시된다', async () => {
    // Given: 일정이 존재하는 상태
    const { user } = setup();
    await screen.findByText('팀 미팅');

    // When: 삭제 버튼을 클릭
    const deleteButton = screen.getByLabelText('Delete event');
    await user.click(deleteButton);

    // Then: 확인 다이얼로그가 표시됨
    expect(screen.getByText('정말 삭제하시겠습니까?')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: '취소' })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: '삭제' })).toBeInTheDocument();
  });

  it('TC002: 취소 버튼 클릭 시 일정이 삭제되지 않는다', async () => {
    // Given: 삭제 확인 다이얼로그가 열린 상태
    const { user } = setup();
    await openDeleteDialog(user);

    // When: 취소 버튼을 클릭
    await user.click(screen.getByRole('button', { name: '취소' }));

    // Then: 일정이 여전히 존재
    expect(screen.getByText('팀 미팅')).toBeInTheDocument();
    expect(screen.queryByText('정말 삭제하시겠습니까?')).not.toBeInTheDocument();
  });
});
```

### 나쁜 예시

```typescript
describe('App', () => {
  it('작동한다', () => {
    // 무엇을 테스트하는지 불명확
    render(<App />);
    expect(screen.getByText('일정')).toBeInTheDocument();
  });

  it('state가 변경된다', () => {
    // 구현 세부사항 테스트
    const wrapper = mount(<App />);
    wrapper.setState({ isOpen: true });
    expect(wrapper.state('isOpen')).toBe(true);
  });
});
```