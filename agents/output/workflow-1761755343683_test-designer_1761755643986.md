## 테스트 전략

### 접근 방식

- 방법론: TDD (Test-Driven Development)
- 원칙: F.I.R.S.T 원칙 준수
- 중점: 사용자 시나리오 중심, 비즈니스 가치 검증

### 중점 영역

1.  핵심 비즈니스 로직: 반복 일정 수정 시 단일/전체 수정 로직, `repeat.type` 변경 및 유지
2.  사용자 인터랙션: 일정 수정 버튼 클릭, 다이얼로그 표시 및 버튼 클릭, 폼 제출
3.  에러 처리: API 호출 실패 시 사용자 피드백
4.  데이터 무결성: 반복 일정 그룹 식별, 각 일정의 날짜 및 반복 정보 유지

### 목표 커버리지

- 라인 커버리지: 90% (의미있는 코드에 대해)
- 브랜치 커버리지: 85% (모든 조건문 분기)
- 함수 커버리지: 95% (public 함수)
- 중요: 단순 커버리지 숫자보다 의미있는 테스트 작성

### 테스트 우선순위

1.  High: 반복 일정 수정 다이얼로그 표시, 단일/전체 수정 로직 분기, 데이터 무결성 (잘못된 일정 수정 방지)
2.  Medium: 다이얼로그 버튼 동작, 스낵바 메시지, 폼 상태 관리
3.  Low: 일반 일정 수정 플로우의 기존 동작 유지

## 테스트 케이스 목록

### TC001: 반복 일정 수정 버튼 클릭 시 범위 선택 다이얼로그 표시

- 기능 ID: F001
- 테스트 유형: integration
- 우선순위: high
- 설명: 반복 일정의 수정 버튼 클릭 시 사용자에게 수정 범위를 묻는 다이얼로그가 올바르게 표시되는지 검증
- Given (초기 조건):
  - 캘린더에 반복 일정이 표시되어 있음 (예: '매주 월요일 팀 미팅')
  - `isRecurringEditDialogOpen` 상태는 false, `eventToModify`는 null
  - `useEventForm`의 `editEvent` 함수는 Mock되어 호출되지 않음을 확인
- When (실행 동작):
  - 사용자가 반복 일정 옆의 수정 버튼을 클릭
- Then (예상 결과):
  - "해당 일정만 수정하시겠어요?" 문구를 포함하는 다이얼로그가 화면에 표시
  - 다이얼로그 내에 "예 (이 일정만)" 버튼이 표시
  - 다이얼로그 내에 "아니오 (모든 일정)" 버튼이 표시
  - `useEventForm`의 `editEvent` 함수가 호출되지 않음
- 검증 포인트:
  1. 다이얼로그 표시: 다이얼로그 텍스트와 버튼이 올바르게 렌더링되는지 확인
  2. 상태 변화: `isRecurringEditDialogOpen`가 true로, `eventToModify`가 클릭한 이벤트 객체로 설정되었는지 확인
- 엣지 케이스:
  - 없음
- Mock/Stub 요구사항:
  - `useEventForm` 훅 Mock: `editEvent` 함수 Mock

### TC002: 일반 일정 수정 버튼 클릭 시 다이얼로그 없이 바로 폼 열림

- 기능 ID: F001
- 테스트 유형: integration
- 우선순위: high
- 설명: 반복 일정이 아닌 일반 일정의 수정 버튼 클릭 시 기존 플로우대로 다이얼로그 없이 바로 수정 폼이 열리는지 검증
- Given (초기 조건):
  - 캘린더에 일반 일정이 표시되어 있음 (예: '점심 약속')
  - `isRecurringEditDialogOpen` 상태는 false, `eventToModify`는 null
- When (실행 동작):
  - 사용자가 일반 일정 옆의 수정 버튼을 클릭
- Then (예상 결과):
  - "해당 일정만 수정하시겠어요?" 다이얼로그가 화면에 표시되지 않음
  - `useEventForm`의 `editEvent` 함수가 클릭한 일반 일정으로 호출됨
- 검증 포인트:
  1. 다이얼로그 미표시: 다이얼로그가 화면에 없는지 확인
  2. 폼 열림: `useEventForm.editEvent`가 올바른 이벤트 객체로 호출되었는지 확인
- 엣지 케이스:
  - 없음
- Mock/Stub 요구사항:
  - `useEventForm` 훅 Mock: `editEvent` 함수 Mock

### TC003: 다이얼로그에서 "예 (이 일정만)" 선택 시 단일 수정 모드로 폼 열림

- 기능 ID: F001, F004
- 테스트 유형: integration
- 우선순위: high
- 설명: 반복 일정 수정 다이얼로그에서 "예 (이 일정만)" 버튼 클릭 시 단일 수정 모드로 폼이 열리고 관련 상태가 설정되는지 검증
- Given (초기 조건):
  - 반복 일정 수정 다이얼로그가 화면에 표시되어 있음
  - `eventToModify`에 수정할 반복 일정 객체가 설정되어 있음
  - `useEventForm` 훅의 `editEvent` 및 `setRecurringEditMode` 함수는 Mock되어 있음
- When (실행 동작):
  - 사용자가 다이얼로그의 "예 (이 일정만)" 버튼을 클릭
- Then (예상 결과):
  - 다이얼로그가 화면에서 사라짐
  - `useEventForm.editEvent` 함수가 `eventToModify`로 호출됨
  - `useEventForm.setRecurringEditMode` 함수가 'single' 인자로 호출됨
- 검증 포인트:
  1. 다이얼로그 닫힘: 다이얼로그가 화면에 없는지 확인
  2. 폼 상태 설정: `editEvent`와 `setRecurringEditMode`가 올바른 인자로 호출되었는지 확인
- 엣지 케이스:
  - 없음
- Mock/Stub 요구사항:
  - `useEventForm` 훅 Mock: `editEvent`, `setRecurringEditMode` 함수 Mock

### TC004: 다이얼로그에서 "아니오 (모든 일정)" 선택 시 전체 수정 모드로 폼 열림

- 기능 ID: F001, F004
- 테스트 유형: integration
- 우선순위: high
- 설명: 반복 일정 수정 다이얼로그에서 "아니오 (모든 일정)" 버튼 클릭 시 전체 수정 모드로 폼이 열리고 관련 상태가 설정되는지 검증
- Given (초기 조건):
  - 반복 일정 수정 다이얼로그가 화면에 표시되어 있음
  - `eventToModify`에 수정할 반복 일정 객체가 설정되어 있음
  - `useEventForm` 훅의 `editEvent` 및 `setRecurringEditMode` 함수는 Mock되어 있음
- When (실행 동작):
  - 사용자가 다이얼로그의 "아니오 (모든 일정)" 버튼을 클릭
- Then (예상 결과):
  - 다이얼로그가 화면에서 사라짐
  - `useEventForm.editEvent` 함수가 `eventToModify`로 호출됨
  - `useEventForm.setRecurringEditMode` 함수가 'all' 인자로 호출됨
- 검증 포인트:
  1. 다이얼로그 닫힘: 다이얼로그가 화면에 없는지 확인
  2. 폼 상태 설정: `editEvent`와 `setRecurringEditMode`가 올바른 인자로 호출되었는지 확인
- 엣지 케이스:
  - 없음
- Mock/Stub 요구사항:
  - `useEventForm` 훅 Mock: `editEvent`, `setRecurringEditMode` 함수 Mock

### TC005: `useEventForm` 초기 상태 및 `recurringEditMode` 관리

- 기능 ID: F004
- 테스트 유형: unit
- 우선순위: medium
- 설명: `useEventForm` 훅의 `recurringEditMode` 상태가 올바르게 초기화되고, `setRecurringEditMode` 및 `resetForm`에 의해 관리되는지 검증
- Given (초기 조건):
  - `useEventForm` 훅을 사용하는 테스트 컴포넌트
- When (실행 동작):
  1. 훅 초기화
  2. `setRecurringEditMode('single')` 호출
  3. `resetForm()` 호출
- Then (예상 결과):
  1. 초기 `recurringEditMode`는 'none'임
  2. `setRecurringEditMode` 호출 후 `recurringEditMode`는 'single'이 됨
  3. `resetForm()` 호출 후 `recurringEditMode`는 다시 'none'이 됨
- 검증 포인트:
  1. 초기값: `recurringEditMode`의 초기값이 'none'인지 확인
  2. 상태 변경: `setRecurringEditMode` 호출 후 값이 올바르게 변경되는지 확인
  3. 초기화: `resetForm` 호출 후 값이 'none'으로 재설정되는지 확인
- 엣지 케이스:
  - 없음
- Mock/Stub 요구사항:
  - 없음 (순수 훅 테스트)

### TC006: `addOrUpdateEvent`에서 일반 일정 수정 시 `saveEvent` 호출

- 기능 ID: F005
- 테스트 유형: integration
- 우선순위: high
- 설명: `App.tsx`의 `addOrUpdateEvent` 함수가 `recurringEditMode`가 'none' (일반 일정 수정)일 때 `useEventOperations.saveEvent`를 올바르게 호출하는지 검증
- Given (초기 조건):
  - `editingEvent`가 설정되어 있고 (기존 일정 수정 상황)
  - `recurringEditMode`가 'none'으로 설정되어 있음
  - `useEventOperations.saveEvent`는 Mock되어 있음
  - `useEventOperations.updateSingleRecurringEvent`, `useEventOperations.updateAllRecurringEvents`는 Mock되어 호출되지 않음을 확인
- When (실행 동작):
  - `addOrUpdateEvent` 함수가 호출됨
- Then (예상 결과):
  - `useEventOperations.saveEvent` 함수가 수정된 이벤트 데이터로 호출됨
  - `useEventOperations.updateSingleRecurringEvent` 및 `updateAllRecurringEvents`는 호출되지 않음
  - `resetForm()`과 `setRecurringEditMode('none')`이 호출됨
- 검증 포인트:
  1. 함수 호출: `saveEvent`만 호출되는지 확인
  2. 인자 전달: `saveEvent`에 올바른 이벤트 데이터가 전달되는지 확인
  3. 폼 초기화: `resetForm`과 `setRecurringEditMode`가 호출되는지 확인
- 엣지 케이스:
  - 없음
- Mock/Stub 요구사항:
  - `useEventForm` 훅 Mock: `editingEvent`, `recurringEditMode`, `resetForm`, `setRecurringEditMode` Mock
  - `useEventOperations` 훅 Mock: `saveEvent`, `updateSingleRecurringEvent`, `updateAllRecurringEvents` Mock

### TC007: `addOrUpdateEvent`에서 반복 일정 단일 수정 시 `updateSingleRecurringEvent` 호출

- 기능 ID: F005, F002
- 테스트 유형: integration
- 우선순위: high
- 설명: `App.tsx`의 `addOrUpdateEvent` 함수가 `recurringEditMode`가 'single'일 때 `useEventOperations.updateSingleRecurringEvent`를 올바르게 호출하는지 검증
- Given (초기 조건):
  - `editingEvent`가 설정되어 있고 (기존 일정 수정 상황)
  - `recurringEditMode`가 'single'으로 설정되어 있음
  - `useEventOperations.updateSingleRecurringEvent`는 Mock되어 있음
  - `useEventOperations.saveEvent`, `useEventOperations.updateAllRecurringEvents`는 Mock되어 호출되지 않음을 확인
- When (실행 동작):
  - `addOrUpdateEvent` 함수가 호출됨
- Then (예상 결과):
  - `useEventOperations.updateSingleRecurringEvent` 함수가 수정된 이벤트 데이터로 호출됨
  - `useEventOperations.saveEvent` 및 `updateAllRecurringEvents`는 호출되지 않음
  - `resetForm()`과 `setRecurringEditMode('none')`이 호출됨
- 검증 포인트:
  1. 함수 호출: `updateSingleRecurringEvent`만 호출되는지 확인
  2. 인자 전달: `updateSingleRecurringEvent`에 올바른 이벤트 데이터가 전달되는지 확인
  3. 폼 초기화: `resetForm`과 `setRecurringEditMode`가 호출되는지 확인
- 엣지 케이스:
  - 없음
- Mock/Stub 요구사항:
  - `useEventForm` 훅 Mock: `editingEvent`, `recurringEditMode`, `resetForm`, `setRecurringEditMode` Mock
  - `useEventOperations` 훅 Mock: `saveEvent`, `updateSingleRecurringEvent`, `updateAllRecurringEvents` Mock

### TC008: `addOrUpdateEvent`에서 반복 일정 전체 수정 시 `updateAllRecurringEvents` 호출

- 기능 ID: F005, F003
- 테스트 유형: integration
- 우선순위: high
- 설명: `App.tsx`의 `addOrUpdateEvent` 함수가 `recurringEditMode`가 'all'일 때 `useEventOperations.updateAllRecurringEvents`를 올바르게 호출하는지 검증
- Given (초기 조건):
  - `editingEvent`가 설정되어 있고 (기존 일정 수정 상황)
  - `recurringEditMode`가 'all'으로 설정되어 있음
  - `useEventOperations.updateAllRecurringEvents`는 Mock되어 있음
  - `useEventOperations.saveEvent`, `useEventOperations.updateSingleRecurringEvent`는 Mock되어 호출되지 않음을 확인
- When (실행 동작):
  - `addOrUpdateEvent` 함수가 호출됨
- Then (예상 결과):
  - `useEventOperations.updateAllRecurringEvents` 함수가 수정된 이벤트 데이터로 호출됨
  - `useEventOperations.saveEvent` 및 `updateSingleRecurringEvent`는 호출되지 않음
  - `resetForm()`과 `setRecurringEditMode('none')`이 호출됨
- 검증 포인트:
  1. 함수 호출: `updateAllRecurringEvents`만 호출되는지 확인
  2. 인자 전달: `updateAllRecurringEvents`에 올바른 이벤트 데이터가 전달되는지 확인
  3. 폼 초기화: `resetForm`과 `setRecurringEditMode`가 호출되는지 확인
- 엣지 케이스:
  - 없음
- Mock/Stub 요구사항:
  - `useEventForm` 훅 Mock: `editingEvent`, `recurringEditMode`, `resetForm`, `setRecurringEditMode` Mock
  - `useEventOperations` 훅 Mock: `saveEvent`, `updateSingleRecurringEvent`, `updateAllRecurringEvents` Mock

### TC009: `updateSingleRecurringEvent`가 단일 일정을 'none'으로 수정하고 아이콘 제거

- 기능 ID: F002
- 테스트 유형: integration
- 우선순위: high
- 설명: `updateSingleRecurringEvent`가 호출될 때, 해당 일정의 `repeat.type`을 'none'으로 변경하고, API 호출 후 UI에서 반복 아이콘이 사라지는지 검증
- Given (초기 조건):
  - Mock된 API 서버가 `PUT /api/events/:id` 요청에 성공 응답을 반환
  - 캘린더에 반복 아이콘이 있는 반복 일정이 표시되어 있음 (ID: 'event-1')
  - `fetchEvents` 및 `showSnackbar`는 Mock되어 있음
- When (실행 동작):
  - `useEventOperations.updateSingleRecurringEvent`가 'event-1'의 데이터로 호출됨
- Then (예상 결과):
  - `PUT /api/events/event-1` API 호출이 발생하며, 요청 본문의 `repeat.type`이 'none'으로 변경되어 전송됨
  - `fetchEvents`가 호출되어 일정 목록이 새로고침됨
  - 성공 스낵바 메시지가 표시됨
  - 'event-1'에 해당하는 일정에서 반복 아이콘이 사라짐 (UI 검증)
- 검증 포인트:
  1. API 호출: `repeat.type: 'none'`을 포함한 PUT 요청 확인
  2. UI 업데이트: `fetchEvents` 호출 및 반복 아이콘 사라짐 확인
  3. 사용자 피드백: 성공 스낵바 메시지 확인
- 엣지 케이스:
  - API 호출 실패 시 에러 스낵바 표시 및 `fetchEvents` 호출 안됨 확인
- Mock/Stub 요구사항:
  - API Mock (MSW 등): `PUT /api/events/:id`
  - `useEventOperations` 훅 Mock: `fetchEvents`, `showSnackbar` Mock

### TC010: `updateAllRecurringEvents`가 동일 그룹 모든 일정을 수정하고 아이콘 유지

- 기능 ID: F003
- 테스트 유형: integration
- 우선순위: high
- 설명: `updateAllRecurringEvents`가 호출될 때, 동일 반복 그룹의 모든 일정이 수정되고, 반복 정보와 아이콘이 유지되는지 검증
- Given (초기 조건):
  - Mock된 API 서버가 `PUT /api/events/:id` 요청에 성공 응답을 반환
  - 캘린더에 동일한 반복 그룹에 속하는 여러 반복 일정이 표시되어 있음 (예: '팀 미팅' 3개)
  - 이 중 하나의 일정(ID: 'event-2')이 수정된 상태 (예: title이 '새 팀 미팅'으로 변경)
  - `fetchEvents` 및 `showSnackbar`는 Mock되어 있음
- When (실행 동작):
  - `useEventOperations.updateAllRecurringEvents`가 'event-2'의 수정된 데이터로 호출됨
- Then (예상 결과):
  - 동일 그룹에 속하는 모든 일정(예: 'event-2', 'event-3', 'event-4')에 대해 각각 `PUT /api/events/:id` API 호출이 발생
  - 각 API 호출 시 `title`, `description` 등 변경된 필드는 반영되나, `id`, `date`, `startTime`, `endTime`, `repeat` 정보는 원래대로 유지됨
  - `fetchEvents`가 호출되어 일정 목록이 새로고침됨
  - 성공 스낵바 메시지가 표시됨
  - 모든 수정된 일정에서 반복 아이콘이 여전히 표시됨 (UI 검증)
- 검증 포인트:
  1. API 호출: 그룹 내 모든 일정에 대한 PUT 요청 및 요청 본문 필드 확인
  2. UI 업데이트: `fetchEvents` 호출 및 반복 아이콘 유지 확인
  3. 사용자 피드백: 성공 스낵바 메시지 확인
  4. 데이터 무결성: `repeat` 정보가 'none'으로 변경되지 않았는지 확인
- 엣지 케이스:
  - API 호출 실패 시 에러 스낵바 표시 및 `fetchEvents` 호출 안됨 확인
  - 다른 그룹의 일정은 수정되지 않음을 확인
- Mock/Stub 요구사항:
  - API Mock (MSW 등): `PUT /api/events/:id`
  - `useEventOperations` 훅 Mock: `fetchEvents`, `showSnackbar`, `events` 상태 (그룹 식별용) Mock

## 테스트 구조 설계

### 파일 구조

```
src/__tests__/
  ├── unit/                    # 단위 테스트 (훅, 유틸리티 함수 등)
  │   ├── useEventForm.spec.ts
  │   └── useEventOperations.spec.ts
  ├── integration/             # 통합 테스트 (컴포넌트 + 훅, App 컴포넌트 등)
  │   └── App.integration.spec.tsx
  └── e2e/                     # E2E 테스트 (선택적, 현재는 통합 테스트로 충분)
```

### 테스트 파일 명명 규칙

- `[테스트대상].[타입].spec.ts`
- 예: `App.integration.spec.tsx`, `useEventForm.unit.spec.ts`

## 테스트 피라미드 구성

### 분포

- 단위 테스트: 7개 (70-80%)
  - `useEventForm` 훅의 `recurringEditMode` 상태 관리 (TC005)
  - `useEventOperations` 내부 헬퍼 함수 (`_callEventApi` 등) (추가될 경우)
- 통합 테스트: 5개 (20-30%)
  - `App` 컴포넌트의 다이얼로그 표시 및 버튼 동작 (TC001, TC002, TC003, TC004)
  - `App` 컴포넌트의 `addOrUpdateEvent` 로직 분기 (TC006, TC007, TC008)
  - `useEventOperations`의 단일/전체 수정 로직과 API 연동 (TC009, TC010)
- E2E 테스트: 0개 (현재 단계에서는 통합 테스트로 충분하며, 추후 필요시 추가)

### 근거

- 단위 테스트 중심: 빠른 피드백, 문제 지점 명확. 특히 훅의 내부 상태 관리 및 순수 로직 검증에 적합.
- 통합 테스트 보완: `App` 컴포넌트와 `useEventForm`, `useEventOperations` 훅 간의 상호작용, 다이얼로그 UI, API 호출 흐름 등 실제 사용 시나리오를 검증. 사용자 관점의 테스트에 중점.
- E2E 최소화: 느리고 깨지기 쉬움. 현재는 핵심 기능의 유기적 연결을 통합 테스트로 충분히 검증 가능.

## 테스트 품질 체크리스트

작성된 테스트 케이스가 다음을 만족하는지 확인:

- [x] 사용자 관점에서 작성되었는가?
- [x] 비즈니스 가치를 검증하는가?
- [x] 테스트 이름만으로 무엇을 검증하는지 이해 가능한가?
- [x] 실패 시 문제 위치를 명확히 알 수 있는가?
- [x] 다른 테스트와 독립적으로 실행 가능한가?
- [x] Given-When-Then이 명확히 구분되는가?
- [x] 엣지 케이스와 에러 케이스를 포함하는가?
- [x] Mock을 적절히 사용하여 외부 의존성을 제어하는가?
- [x] 구현 세부사항이 아닌 동작을 테스트하는가?
- [x] 단언문(assertion)이 명확하고 구체적인가?
