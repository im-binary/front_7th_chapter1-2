### 기존 코드 분석

- 관련 파일:

  - `src/App.tsx` - 메인 애플리케이션 컴포넌트, 일정 목록 렌더링, 수정 버튼 핸들러, `addOrUpdateEvent` (폼 제출 로직), `isRepeatEvent` 헬퍼 함수 포함.
  - `src/hooks/useEventForm.ts` - 일정 폼의 상태 관리, `editEvent` 함수 포함.
  - `src/hooks/useEventOperations.ts` - 일정 CRUD API 호출 로직 (`saveEvent`, `deleteEvent`, `saveMultipleEvents`) 포함.
  - `src/types.ts` - `Event` 및 `RepeatInfo` 타입 정의.

- 주요 함수/컴포넌트 및 역할:

  - `App` 컴포넌트: `filteredEvents.map` 내 `Edit` 버튼 클릭 시 `useEventForm`의 `editEvent`를 호출. `addOrUpdateEvent` 함수는 폼 데이터를 기반으로 `useEventOperations`의 `saveEvent` 또는 `saveMultipleEvents`를 호출.
  - `useEventForm` 훅: `editEvent(event: Event)`는 선택된 일정의 데이터를 폼에 채우고 `editingEvent` 상태를 설정.
  - `useEventOperations` 훅: `saveEvent`는 `editing` 상태에 따라 POST 또는 PUT 요청을 수행하여 단일 일정을 저장/수정. `saveMultipleEvents`는 여러 일정을 추가.
  - `isRepeatEvent(event: Event)`: `event.repeat.type`이 'none'이 아닌 경우 true를 반환하여 반복 아이콘 표시 여부를 결정.

- 데이터 흐름 (일정 수정 시):
  1. `App.tsx`에서 사용자 `Edit` 버튼 클릭.
  2. `useEventForm().editEvent(event)` 호출, 폼 필드 채워지고 `editingEvent`가 설정됨.
  3. 폼 수정 후 `일정 수정` 버튼 클릭 시 `App.tsx`의 `addOrUpdateEvent` 호출.
  4. `addOrUpdateEvent`는 `editingEvent`가 존재하므로 `useEventOperations().saveEvent`를 호출 (PUT 요청).

### 수정 대상

1.  **반복 일정 수정 범위 선택 다이얼로그 (요구사항 1)**

    - 파일: `src/App.tsx`
    - 유형: COMPONENT, FUNCTION, STATE
    - 이름: `App` 컴포넌트, `Edit` 버튼 `onClick` 핸들러, 신규 `useState` 및 `Dialog` UI
    - 현재 동작: `Edit` 버튼 클릭 시 `isRepeatEvent`와 상관없이 `useEventForm().editEvent`를 즉시 호출.
    - 변경 필요:
      1.  신규 `useState` 변수 `isRecurringEditDialogOpen` (boolean) 및 `eventToModify` (Event | null) 추가.
      2.  `Edit` 버튼 `onClick` 핸들러 로직 변경:
          - `isRepeatEvent(event)`가 true인 경우, `setEventToModify(event)` 및 `setIsRecurringEditDialogOpen(true)` 호출.
          - `isRepeatEvent(event)`가 false인 경우, 기존처럼 `editEvent(event)` 호출.
      3.  `App.tsx`에 `isRecurringEditDialogOpen` 상태에 따라 표시될 새로운 Material-UI `Dialog` 컴포넌트 추가.
          - 다이얼로그 내용: "해당 일정만 수정하시겠어요?"
          - 버튼: "예 (이 일정만)", "아니오 (모든 일정)".
      4.  다이얼로그의 각 버튼에 대한 핸들러 함수 (`handleConfirmSingleEdit`, `handleConfirmAllEdit`) 추가. 이 함수들은 `useEventForm`의 `editEvent`를 호출하여 폼을 채우고, `useEventForm`의 새로운 `recurringEditMode` 상태를 설정.
    - 상수만 변경?: 아닙니다. 새로운 UI, 상태 관리, 조건부 로직이 필요합니다.
    - 영향 범위: 일정 목록의 `Edit` 버튼 렌더링 및 `onClick` 로직, `App` 컴포넌트의 UI 구조.

2.  **반복 일정 단일 수정 기능 (요구사항 2)**

    - 파일: `src/hooks/useEventOperations.ts`
    - 유형: FUNCTION
    - 이름: `useEventOperations` 훅 내 신규 함수 `updateSingleRecurringEvent`
    - 현재 동작: 해당 기능 없음.
    - 변경 필요:
      1.  `useEventOperations` 훅 내에 `updateSingleRecurringEvent(eventToUpdate: Event)` 함수 추가.
      2.  이 함수는 `eventToUpdate`의 `repeat.type`을 'none'으로 변경한 후, `/api/events/${eventToUpdate.id}` 엔드포인트에 `PUT` 요청을 보냄. 기존 `saveEvent`의 내부 API 호출 로직을 재활용할 수 있도록 `_callEventApi`와 같은 내부 헬퍼 함수를 추출하는 것을 권장.
      3.  성공 시 `fetchEvents()`를 호출하여 UI를 업데이트하고, 스낵바 메시지 표시.
      4.  `useEventOperations` 훅의 반환 객체에 `updateSingleRecurringEvent`를 추가.
    - 상수만 변경?: 아닙니다. 새로운 함수와 로직이 필요합니다.
    - 영향 범위: `App.tsx`의 `addOrUpdateEvent` 함수, API 호출.

3.  **반복 일정 전체 수정 기능 (요구사항 3)**

    - 파일: `src/hooks/useEventOperations.ts`
    - 유형: FUNCTION
    - 이름: `useEventOperations` 훅 내 신규 함수 `updateAllRecurringEvents`
    - 현재 동작: 해당 기능 없음.
    - 변경 필요:
      1.  `useEventOperations` 훅 내에 `updateAllRecurringEvents(modifiedEvent: Event)` 함수 추가.
      2.  이 함수는 `useEventOperations` 내부의 `events` 상태를 필터링하여 `modifiedEvent`와 `title`, `startTime`, `endTime`, `repeat.type`이 모두 같은 모든 반복 일정 그룹을 식별.
      3.  식별된 각 일정에 대해, `modifiedEvent`의 `title`, `description`, `location`, `category`, `notificationTime` 필드를 업데이트하되, 각 일정의 `id`, `date`, `startTime`, `endTime`, `repeat` 정보는 유지한 채 `/api/events/${eventInGroup.id}` 엔드포인트에 `PUT` 요청을 보냄.
      4.  성공 시 `fetchEvents()`를 호출하여 UI를 업데이트하고, 스낵바 메시지 표시.
      5.  `useEventOperations` 훅의 반환 객체에 `updateAllRecurringEvents`를 추가.
    - 상수만 변경?: 아닙니다. 새로운 함수와 복잡한 로직이 필요합니다.
    - 영향 범위: `App.tsx`의 `addOrUpdateEvent` 함수, API 호출.

4.  **`src/hooks/useEventForm.ts` 수정**

    - 파일: `src/hooks/useEventForm.ts`
    - 유형: FUNCTION, STATE
    - 이름: `useEventForm` 훅, `resetForm`
    - 현재 동작: `editingEvent`만으로 수정 여부 판단.
    - 변경 필요:
      1.  신규 `useState` 변수 `recurringEditMode: 'none' | 'single' | 'all'` 추가 (초기값 'none').
      2.  `resetForm` 함수에 `setRecurringEditMode('none')` 추가.
      3.  훅의 반환 값에 `recurringEditMode` 및 `setRecurringEditMode` 추가.
    - 상수만 변경?: 아닙니다. 새로운 상태와 그에 따른 로직이 필요합니다.
    - 영향 범위: `App.tsx`에서 수정 모드를 판단하는 데 사용.

5.  **`src/App.tsx`의 `addOrUpdateEvent` 수정**
    - 파일: `src/App.tsx`
    - 유형: FUNCTION
    - 이름: `addOrUpdateEvent`
    - 현재 동작: `editingEvent` 여부에 따라 `saveEvent` 호출.
    - 변경 필요:
      1.  `editingEvent`가 true인 경우, `useEventForm`에서 가져온 `recurringEditMode` 값에 따라 분기.
      2.  `recurringEditMode`가 'single'이면 `updateSingleRecurringEvent` 호출.
      3.  `recurringEditMode`가 'all'이면 `updateAllRecurringEvents` 호출.
      4.  `recurringEditMode`가 'none' (일반 일정 수정)이면 기존 `saveEvent` 호출 로직 유지 (겹침 감지 포함).
      5.  수정 완료 후 `resetForm()` 및 `setRecurringEditMode('none')` 호출.
    - 상수만 변경?: 아닙니다. 기존 함수의 핵심 로직에 조건부 분기가 추가됩니다.
    - 영향 범위: 일정 수정 시 최종 저장 동작.

### 기능 목록

| ID   | 이름                           | 타입            | 파일                              | 복잡도   | 수락 기준                                                                                               |
| ---- | ------------------------------ | --------------- | --------------------------------- | -------- | ------------------------------------------------------------------------------------------------------- |
| F001 | 반복 일정 수정 범위 다이얼로그 | CREATE_NEW      | `src/App.tsx`                     | moderate | - [ ] 반복 일정 수정 버튼 클릭 시 다이얼로그 표시 확인<br>- [ ] 다이얼로그 버튼 정상 동작 확인          |
| F002 | 반복 일정 단일 수정            | CREATE_NEW      | `src/hooks/useEventOperations.ts` | moderate | - [ ] 선택한 일정만 수정되고 `repeat.type`이 'none'으로 변경됨을 확인<br>- [ ] 반복 아이콘 사라짐 확인  |
| F003 | 반복 일정 전체 수정            | CREATE_NEW      | `src/hooks/useEventOperations.ts` | moderate | - [ ] 동일 그룹 모든 일정 수정 확인<br>- [ ] 반복 정보 및 날짜 유지 확인<br>- [ ] 반복 아이콘 유지 확인 |
| F004 | 폼 반복 수정 모드 상태         | MODIFY_EXISTING | `src/hooks/useEventForm.ts`       | simple   | - [ ] `recurringEditMode` 상태 추가 및 관리 확인                                                        |
| F005 | 저장 로직 분기                 | MODIFY_EXISTING | `src/App.tsx`                     | moderate | - [ ] `addOrUpdateEvent`가 `recurringEditMode`에 따라 올바른 수정 함수를 호출하는지 확인                |

### 의존성

- F001 (다이얼로그)은 F004 (폼 상태)에 의존.
- F005 (저장 로직 분기)는 F002 (단일 수정), F003 (전체 수정), F004 (폼 상태)에 의존.
- F002, F003은 `useEventOperations` 훅의 `events` 상태 및 내부 API 호출 로직에 의존.
- 반복 아이콘 표시는 `App.tsx`의 `isRepeatEvent` 함수가 `repeat.type`을 확인하므로, F002에서 `repeat.type`을 'none'으로 변경하면 자동으로 아이콘이 사라집니다.

### 추천 구현 순서

1.  **F004 (폼 반복 수정 모드 상태) 구현**: `src/hooks/useEventForm.ts`에 `recurringEditMode` 상태 추가 및 관련 로직 수정.
2.  **F001 (반복 일정 수정 범위 다이얼로그) 구현**:
    - `src/App.tsx`에 `isRecurringEditDialogOpen`, `eventToModify` 상태 추가.
    - `Edit` 버튼 `onClick` 핸들러 수정.
    - 다이얼로그 UI 및 `handleConfirmSingleEdit`, `handleConfirmAllEdit` 함수 추가 (이 함수들에서 `setRecurringEditMode` 호출).
3.  **`src/hooks/useEventOperations.ts` 리팩토링 및 F002, F003 구현**:
    - `saveEvent` 내 API 호출 로직을 `_callEventApi`와 같은 내부 헬퍼 함수로 추출하여 중복 방지.
    - `updateSingleRecurringEvent` 함수 구현.
    - `updateAllRecurringEvents` 함수 구현.
    - 이 두 함수를 `useEventOperations`의 반환 객체에 추가.
4.  **F005 (저장 로직 분기) 구현**: `src/App.tsx`의 `addOrUpdateEvent` 함수 수정하여 `recurringEditMode`에 따라 적절한 `useEventOperations` 함수 호출.
5.  모든 변경 사항에 대한 테스트 진행. 특히 기존 일정 수정 및 생성 플로우가 손상되지 않았는지 확인.
