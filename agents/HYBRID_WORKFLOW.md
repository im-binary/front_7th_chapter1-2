# 🔄 Hybrid AI Workflow (Gemini + Copilot)

## 개요

Gemini의 빠른 구조화 능력과 GitHub Copilot의 정확한 코드 이해를 결합한 Hybrid 접근 방식입니다.

## 핵심 아이디어

```
┌─────────────┐      ┌──────────────┐      ┌──────────┐
│   Gemini    │ ───> │   초안 생성   │ ───> │  Copilot │
│  (빠른 분석) │      │  (구조화됨)   │      │ (정확한  │
│             │      │              │      │  보완)   │
└─────────────┘      └──────────────┘      └──────────┘
      ↓                     ↓                     ↓
  전체 구조 파악         Markdown 문서        실제 코드 작성
```

### Gemini의 역할

- ✅ 빠른 요구사항 분석
- ✅ 구조화된 초안 생성
- ✅ 전체적인 방향 제시
- ❌ 실제 코드 작성 (X)
- ❌ 파일 경로 검증 (X)

### Copilot의 역할

- ✅ 워크스페이스 전체 이해
- ✅ 실제 코드 기반 검증
- ✅ 파일 생성/수정
- ✅ 테스트 실행
- ❌ 구조화된 분석 (Gemini가 더 빠름)

## 사용 방법

### Step 1: Gemini 초안 생성

```bash
pnpm agent:run -r "일정 카테고리 필터링 기능 추가"
```

**출력 예시:**

```
🚀 Hybrid AI 워크플로우 시작 (Gemini + Copilot)
📝 요구사항: 일정 카테고리 필터링 기능 추가

============================================================
📋 Step 1: Gemini가 기능 명세서 초안 작성 중...
============================================================

📄 Gemini 초안 (미리보기):

────────────────────────────────────────────────────────────
## 기존 코드 분석

### 관련 파일
- `src/App.tsx` - 메인 컴포넌트
- `src/hooks/useSearch.ts` - 검색 로직
...
────────────────────────────────────────────────────────────

🔄 Hybrid 프로세스:
  1️⃣  Gemini 초안 생성 완료 ✅
  2️⃣  이제 Copilot이 검토하고 보완할 차례입니다

============================================================
👉 다음 단계: 아래 내용을 복사해서 저(GitHub Copilot)에게 요청하세요
============================================================

💬 Copilot 요청 프롬프트:

────────────────────────────────────────────────────────────
# Gemini 초안 검토 및 보완 요청

## 요구사항
일정 카테고리 필터링 기능 추가

## Gemini가 작성한 초안
[전체 초안 내용]

## 요청사항
위의 Gemini 초안을 검토하고, 실제 워크스페이스의 코드를 기반으로 다음을 보완해주세요:
...
────────────────────────────────────────────────────────────
```

### Step 2: Copilot에게 요청

위에서 출력된 프롬프트를 복사해서 Copilot에게 전달하거나, 간단히:

```
@workspace Gemini 초안 검토하고 실제 코드 기반으로 보완해줘
```

**Copilot이 수행:**

1. 실제 파일 경로 검증
2. 함수명/클래스명 확인
3. 코드 패턴 분석
4. 엣지 케이스 추가
5. 최소 변경 원칙 적용

### Step 3-5: 계속 Copilot과 대화

나머지 단계는 Copilot에게 직접 요청하는 것이 가장 효율적:

```
"테스트 설계해줘"
"테스트 코드 작성해줘"
"구현해줘"
"리팩토링해줘"
```

## 장점

### ✅ Gemini의 한계 보완

- 맥락 공유 어려움 → Copilot이 워크스페이스 전체 이해
- 추상적인 분석 → Copilot이 실제 코드로 검증
- 파일 경로 오류 → Copilot이 정확한 경로 사용

### ✅ 빠른 시작

- Gemini가 1-2분 내 구조화된 초안 생성
- 처음부터 다시 생각할 필요 없음

### ✅ 정확한 결과

- Copilot이 실제 코드 기반으로 검증
- 프로젝트 패턴 유지
- 최소 변경 원칙 적용

## 비교: 기존 방식 vs Hybrid

| 항목              | Gemini만    | Copilot만 | Hybrid      |
| ----------------- | ----------- | --------- | ----------- |
| 초안 속도         | ⚡⚡⚡ 빠름 | 🐢 느림   | ⚡⚡⚡ 빠름 |
| 정확도            | ⚠️ 낮음     | ✅ 높음   | ✅ 높음     |
| 워크스페이스 이해 | ❌ 없음     | ✅ 완벽   | ✅ 완벽     |
| 구조화            | ✅ 우수     | ⚠️ 보통   | ✅ 우수     |
| 실제 코드 작성    | ❌ 불가능   | ✅ 가능   | ✅ 가능     |

## 실제 사용 예시

### 예시 1: 간단한 기능 추가

```bash
# Step 1: Gemini 초안
$ pnpm agent:run -r "일정 제목에 [신규] 접두사 추가"

# Step 2: Copilot 보완
→ "@workspace 초안 검토해줘"

# Step 3-5: Copilot과 대화
→ "테스트 작성해줘"
→ "구현해줘"
→ "테스트 실행해줘"
```

### 예시 2: 복잡한 기능 추가

```bash
# Step 1: Gemini 초안
$ pnpm agent:run -r "카테고리별 필터링 + 검색 기능 통합"

# Step 2: Copilot 상세 분석
→ 출력된 프롬프트 복사 → Copilot에 전달
→ Copilot이 실제 코드 기반으로 상세 분석

# Step 3: 테스트 설계
→ "위 분석 바탕으로 테스트 설계해줘"

# Step 4: 구현
→ "테스트 작성하고 구현해줘"

# Step 5: 검증
→ "테스트 실행하고 리팩토링해줘"
```

## 팁

### 1. Step 1만 CLI 사용

대부분의 경우 `pnpm agent:run -r "요구사항"` 한 번만 실행하고, 나머지는 Copilot과 대화

### 2. 프롬프트 복사 활용

CLI가 출력하는 Copilot 프롬프트를 그대로 복사하면 효과적

### 3. 단계 건너뛰기

간단한 기능이면 Step 1 → 바로 구현 요청 가능

### 4. 중간 검증

각 단계마다 Copilot에게 "이게 맞아?" 확인 가능

## 문제 해결

### Q: Gemini 초안이 너무 추상적이에요

A: 괜찮습니다! Copilot이 보완해줍니다.

### Q: Copilot 프롬프트가 너무 길어요

A: 간단히 "@workspace 초안 검토해줘"만 해도 됩니다. Copilot이 agents/output/ 파일을 찾아 읽습니다.

### Q: Step 2-5는 언제 CLI로 실행하나요?

A: 거의 안 씁니다. Copilot과 직접 대화하는 게 더 빠르고 유연합니다.

### Q: Gemini가 없으면 안 되나요?

A: Copilot만으로도 가능하지만, Gemini 초안이 있으면 시작이 빠릅니다.

## 요약

1. **Step 1**: `pnpm agent:run -r "요구사항"` → Gemini 초안 생성
2. **Step 2-∞**: Copilot과 대화 → 보완, 구현, 테스트, 리팩토링

**핵심**: Gemini는 킥스타터, Copilot이 실제 작업자
